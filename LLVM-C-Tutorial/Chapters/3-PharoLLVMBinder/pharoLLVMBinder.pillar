&!!Pharo LLVM Bindings

!!!How can we use LLVM from Pharo?
In order to use LLVM from Pharo, the main solution is to call the LLVM C bindings
and use those thanks to the uFFI package (Unified Foreign Function Interface).
This package is a façade to all external libraries that one might want to use
from within Pharo. C libraries can therefore be called and used.

Even though Pharo and C are extremely different, the call can operate by marshalling
correctly the different types, structures and by binding the different functions
correctly. In order to use the Pharo uFFI library, we will go over the piece of
code we wrote in the first chapter and try to make it work from within a Pharo
image.

!!!Pharo package and first function
The first thing to do when creating an external library binding in Pharo is to
create a subclass of the ==FFILibrary== class that will be the façade of our
bindings. It will hold the external functions as well as a reference to the
library we are calling.

[[[language=Pharo
FFILibrary subclass: #LLVMBinder
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'LLVMBinder'
]]]

And we can already specify the external library we will be using:
[[[language=Pharo
LLVMBinder >> macLibraryName
  ^ 'libLLVM.dylib'
]]]

The first function we will write the binding for will be the first one we wrote
in the ==sum.c== code: ==LLVMCreateModule()==. However, here comes the first issue.
This function should output an object of type ==LLVMModuleRef== however Pharo has
no idea what that object is and what its name means. By taking a look at the
documentation of the *LLVMModuleRef>https://llvm.org/doxygen/group__LLVMCSupportTypes.html#gad1d1bb5f901c903a0cf09c5a053c9c56*,
we can see that the type ==LLVMModuleRef== is in fact an alias for an ==LLVMOpaqueModule*==.

In the end, we simply shifted the problem. Pharo still does not know what an
==LLVMOpaqueModule== is. However, the ==Opaque== indication means it has been
developed with the idea that the users should not have to look inside this type.
The uFFI package can use this indication with the implementation of ==FFIOpaqueObject==s.
Therefore, we can define a new ==FFIOpaqueObject== in our package:

[[[language=Pharo
FFIOpaqueObject subclass: #LLVMOpaqueModule
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'LLVMBinder'
]]]

In order to implement the alias(es), the handiest way is to create a ==SharedPool==
of the different types we might need to get alias from or with. This can be done
as follows:

First, create the ==SharedPool== and add ==LLVMModuleRef== as a class variable:
[[[language=Pharo
SharedPool subclass: #LLVMTypes
	instanceVariableNames: ''
	classVariableNames: 'LLVMModuleRef'
	package: 'LLVMBinder'
]]]

Then, from within the ==initialize== class method, add the following line:
[[[language=Pharo
LLVMTypes class >> initialize
	LLVMModuleRef := 'LLVMOpaqueModule*'.
]]]

Finally, add the shared pool to the ==LLVMBinder== in its class definition:
[[[language=Pharo
FFILibrary subclass: #LLVMBinder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'LLVMTypes'
	package: 'LLVMBinder'
]]]

Do not forget to execute this initialisation or the alias will not be taken in
consideration!

[[[language=Pharo
LLVMTypes initialize.
]]]

We can now use ==LLVMModuleRef== as if it was ==LLVMOpaqueModule*==
and it will be recognised by Pharo. Our first method ==LLVMCreateModule()== can
therefore be written:

[[[language=Pharo
LLVMBinder >> createModuleWithName: aName
	^ self ffiCall: #(LLVMModuleRef LLVMModuleCreateWithName(String aName))
]]]
*LLVMModuleCreateWithName()>https://llvm.org/doxygen/group__LLVMCCoreModule.html#ga8cf6711b9359fb55d081bfc5e664370c*

The call to the external function is made through the use of ==ffiCall:== and
the correct function signature following it.

Let's try our first function! In a Playground, write and execute the following:
[[[language=Pharo
| binder |
LLVMTypes initialize.
binder := LLVMBinder uniqueInstance.
binder createModuleWithName: 'myModule'.
>>> a LLVMOpaqueModule((void*)@ 16r7FC032003D30)
]]]

!!!Definition of the others opaque objects

From what we have seen in the previous part and by looking at the documentation,
the different objects we will need are represented as alias of opaque objects,
just as our ==LLVMModuleRef== and ==LLVMOpaqueModule==. Therefore, we can use the
same process for all of them:
- Add a class variable to our shared pool ==LLVMTypes==.
- Add the alias to the class-side ==initialize== method.

The objects and the aliases we will need are the following:
- ==LLVMModuleRef== & ==LLVMOpaqueModule==
- ==LLVMTypeRef== & ==LLVMOpaqueType==.
- ==LLVMValueRef== & ==LLVMOpaqueValue==.
- ==LLVMBasicBlockRef== & ==LLVMOpaqueBasicBlock==.
- ==LLVMBuilderRef== & ==LLVMOpaqueBuilder==.
- ==LLVMBool== & ==int==.

(from the documentation: *LLVMTypes>https://llvm.org/doxygen/group__LLVMCSupportTypes.html*)

The final definitions should therefore be:
[[[language=Pharo
SharedPool subclass: #LLVMTypes
	instanceVariableNames: ''
	classVariableNames: 'LLVMBasicBlockRef LLVMBool LLVMBuilderRef LLVMModuleRef LLVMTypeRef LLVMValueRef'
	package: 'LLVMBinder'
]]]

[[[language=Pharo
LLVMTypes class >> initialize
	LLVMModuleRef := 'LLVMOpaqueModule*'.
	LLVMTypeRef := 'LLVMOpaqueType*'.
	LLVMValueRef := 'LLVMOpaqueValue*'.
	LLVMBasicBlockRef := 'LLVMOpaqueBasicBlock*'.
	LLVMBuilderRef := 'LLVMOpaqueBuilder*'.
	LLVMBool := #int.
]]]

!!!Definition of the other functions

Apart from the array definition that needs a bit more work and explanations,
the other bindings are pretty straightforward.

[[[language=Pharo
LLVMBinder >> createFunctionTypeWithReturnType: aType parametersVector: anArray arity: anInteger andIsVaridic: aBooleanInteger
	^ self ffiCall: #(LLVMTypeRef LLVMFunctionType(LLVMTypeRef aType,
																 LLVMTypeRef* anArray,
																 unsigned anInteger,
																 LLVMBool aBooleanInteger))
]]]
*LLVMFunctionType()>https://llvm.org/doxygen/group__LLVMCCoreTypeFunction.html#ga8b0c32e7322e5c6c1bf7eb95b0961707*

[[[language=Pharo
LLVMBinder >> appendBasicBlockNamed: aName toFunction: aFunctionName
	^ self ffiCall: #(LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef aFunctionName,
																			  String aName))
]]]
*LLVMAppendBasicBlock()>https://llvm.org/doxygen/group__LLVMCCoreValueBasicBlock.html#ga74f2ff28344ef72a8206b9c5925be543*

[[[language=Pharo
LLVMBinder >> createBuilder
	^ self ffiCall: #(LLVMBuilderRef LLVMCreateBuilder())
]]]
*LLVMCreateBuilder()>https://llvm.org/doxygen/group__LLVMCCoreInstructionBuilder.html#gaceec9933fd90a94ea5ebb40eedf6136d*

[[[language=Pharo
LLVMBinder >> positionBuilder: aBuilderReference atEndOfBasicBlock: aBasicBlockName
	self ffiCall: #(void LLVMPositionBuilderAtEnd(LLVMBuilderRef aBuilderReference,
															                	LLVMBasicBlockRef aBasicBlockName))
]]]
*LLVMPositionBuilderAtEnd()>https://llvm.org/doxygen/group__LLVMCCoreInstructionBuilder.html#gafa58ecb369fc661ff7e58c19c46053f0*

[[[language=Pharo
LLVMBinder >> addValue: aValue toValue: anotherValue andStoreIn: aTempName using: aBasicBlockReference
	^ self ffiCall: #(LLVMValueRef LLVMBuildAdd	(LLVMBuilderRef aBasicBlockReference,
                                               LLVMValueRef 	aValue,
                                               LLVMValueRef 	anotherValue,
                                               const char * 	aTempName ))
]]]
*LLVMBuildAdd()>https://llvm.org/doxygen/group__LLVMCCoreInstructionBuilder.html#ga5e20ba4e932d72d97a69e07ff54cfa81*

[[[language=Pharo
LLVMBinder >> buildReturnValue: aValue withBuilder: aBuilder
	^ self ffiCall: #(LLVMValueRef LLVMBuildRet	(LLVMBuilderRef aBuilder,
				                                       LLVMValueRef 	aValue))
]]]
*LLVMBuildRet()>https://llvm.org/doxygen/group__LLVMCCoreInstructionBuilder.html#gae4c870d69f9787fe98a824a634473155*


These are all the different functions we used in Chapter 1. We can now take a look
at the parameters array that we need to create the function. One way to define
it is to use an ==FFIArray== of type ==LLVMTypeRef==. We can then fill it up with
the needed type, e.g. ==LLVMInt32Type==. Providing a function ==createParametersArrayWithSize:==
will handle the array creation for us. We can write it as follows:

[[[language=Pharo
LLVMBinder >> createParametersTypeArrayWithSize: aNumber
	^  FFIArray newType: LLVMTypeRef size: aNumber
]]]

In order to then populate the array, we can do the following:

[[[language=Pharo
| binder paramArray |
LLVMTypes initialize.
binder := LLVMBinder uniqueInstance.

paramArray := binder createParametersTypeArrayWithSize: 2.
paramArray at:1 put: binder createInt32Type handle.
paramArray at:2 put: binder createInt32Type.
]]]

!!!Generate the bitcode

WIP
